import adsk.core
import adsk.fusion
from adsk.core import SelectionCommandInput, DropDownStyles

import traceback
import json
from pathlib import Path
# import logging
# import logging.handlers

from ..apper import apper
from ..lib.snaplib.geometry import Cantilever
from ..lib.snaplib.control import value_input, JsonUpdater
from ..lib.snaplib.control import GapProfileSettings
from ..lib.snaplib.control import ProfileSwitcher, ProfileModifier
from ..lib.snaplib.configure import CONFIG_PATH
from ..lib.snaplib import configure

from .CantileverCommand import size_parameters

app = adsk.core.Application.get()
ui = app.userInterface
handlers = []

DEFAULT_SIZE = 1  # equivalent to 10 mm
DEFAULT_STRAIN = 0.024
DEFAULT_NOSE_ANGLE = 70
DEFAULT_BOTTOM_RADIUS = 0
DEFAULT_X_POSITION = "middle"
DEFAULT_Y_POSITION = "top"

def build(args, preview=False):
    try:
        design = adsk.fusion.Design.cast(app.activeProduct)
        rootComp = design.rootComponent
        inputs = args.command.commandInputs

        # Build parameters
        pos_parameters = ["x_location", "y_location"]
        parameters = {}
        parameters["x_location"] = DEFAULT_X_POSITION
        parameters["y_location"] = DEFAULT_Y_POSITION

        # Calculate parameters on the basis of size
        size = inputs.itemById("size").value
        values = size_parameters(size)
        values["strain"] = DEFAULT_STRAIN # Adding a hardcoded strain
        values["nose_angle"] = DEFAULT_NOSE_ANGLE # hardcoded nose angle
        values["bottom_radius"] = DEFAULT_BOTTOM_RADIUS

        #  Add the parameters inferred from the size parameter
        for par_id, value in values.items():
            parameters[par_id] = value

        # Retrieve the data from the parameters that are specified
        try:
            for par_id in ["extra_length", "length_gap", "width_gap", "extrusion_gap"]:
                par_value = inputs.itemById(par_id).value
                parameters[par_id] = par_value
            for par_id in pos_parameters:
                position = inputs.itemById(par_id).selectedItem.name
                parameters[par_id] = position
        except:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()) + f"\n{par_id=}")

        joint_origin = None
        joint_input = inputs.itemById("selected_origin")
        if joint_input.selectionCount == 1:
            joint_origin = joint_input.selection(0).entity

        join_body = None
        join_body_input = inputs.itemById("join_body")
        if join_body_input.selectionCount == 1:
            join_body = join_body_input.selection(0).entity

        cut_body_input = inputs.itemById("cut_bodies")
        cut_bodies = []
        body_count = cut_body_input.selectionCount
        for i in range(body_count):
            body = cut_body_input.selection(i).entity
            cut_bodies.append(body)

            # Make cut bodies transparent in preview mode
            if preview:
                body.opacity = 0.5

        # Performing the actual operations
        timeline_start = design.timeline.markerPosition

        cant = Cantilever(rootComp, parameters,
                   target_joint_org=joint_origin,
                   join_body=join_body,
                   cut_bodies=cut_bodies)

        # Remove the component if a join-body operation was performed
        if join_body:
            rootComp.features.removeFeatures.add(cant.occurrence)

        timeline_end = design.timeline.markerPosition
        timeline_group = design.timeline.timelineGroups.add(timeline_start,
                                                            timeline_end-1)
        timeline_group.name = "Cantilever"

    except:
        if ui:
            ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))


def mating_force(parameters):
    pass

class InputLimiter(adsk.core.ValidateInputsEventHandler):
    """
    Triggered when the user makes a change to any fields, and in fact it also
    triggers a bunch of additional times. Don't know why.
    If all the parameters are within acceptable intervals, it does nothing, and
    allows ExecutePreviewHandler or ExecuteHandler to be triggered. If any
    value is out of bounds, nothing happens, and any features that were
    previously generated by ExecutePreviewHandler will disappear.
    """
    def __init__(self):
        super().__init__()
        # self.logger = logging.getLogger("InputLimiter")

    def notify(self, args):
        pass

class MyCommandExecutePreviewHandler(adsk.core.CommandEventHandler):
    """
    Triggered when user makes any change to a parameter that is related to
    performing the feature operations.
    """
    def __init__(self):
        super().__init__()

    def notify(self, args):
        build(args, preview=True)

class MyCommandExecuteHandler(adsk.core.CommandEventHandler):
    """
    Triggered when user clicks OK in command interface.
    """
    def __init__(self):
        super().__init__()

    def notify(self, args):
        try:
            design = adsk.fusion.Design.cast(app.activeProduct)
            if design:
                build(args, preview=False)
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))


class SimpleCantileverCommand(apper.Fusion360CommandBase):
    GEOMETRY_PARAMETERS = [
        {
            "id": "top_radius",
            "display_text": "Top Radius",
            "units": "mm"
        },
        {
            "id": "bottom_radius",
            "display_text": "Bottom Radius",
            "units": "mm"
        },
        {
            "id": "nose_angle",
            "display_text": "Nose angle",
            "units": ""
        },
        {
            "id": "thickness",
            "display_text": "Thickness",
            "units": "mm"
        },
        {
            "id": "length",
            "display_text": "Length",
            "units": "mm"
        },
        {
            "id": "extrusion_distance",
            "display_text": "Extrusion distance",
            "units": "mm"
        },
        {
            "id": "strain",
            "display_text": "Strain",
            "units": ""
        },
    ]

    GAP_PARAMETERS = [
        {
            "id": "width_gap",
            "display_text": "Thickness gap",
            "units": "mm"
        },
        {
            "id": "extrusion_gap",
            "display_text": "Extrusion gap",
            "units": "mm"
        },
        {
            "id": "length_gap",
            "display_text": "Length gap",
            "units": "mm"
        },
        {
            "id": "extra_length",
            "display_text": "Extra length",
            "units": "mm"
        },
    ]

    def __init__(self, name: str, options: dict):
        super().__init__(name, options)

        # Loading references relative to this projects root
        self.profiles_path = CONFIG_PATH / "ProfileData" / "Cantilever.json"

        self.root_dir = self.fusion_app.root_path
        self.resources_path = self.root_dir / "commands" / "resources" / \
                              "CantileverCommand"
        self.tool_clip_file_path = self.resources_path / "toolclip.png"

    def on_execute(self, command: adsk.core.Command,
                   inputs: adsk.core.CommandInputs,
                   args: adsk.core.CommandEventArgs, input_values: dict):
        try:
            myCmdDef = ui.commandDefinitions.itemById(
                'SelectionEventsSample_Python')
            if myCmdDef is None:
                myCmdDef = ui.commandDefinitions.addButtonDefinition(
                    'SelectionEventsSample_Python',
                    'Create cantilever', '', '')

            # prevent this module from being terminateD when the script returns,
            # because we are waiting for event handlers to fire
            adsk.autoTerminate(False)
            myCmdDef.execute()
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))

    def on_run(self):
        super().on_run()
        # The image that pops up when hovering over the command icon
        self.command_definition.toolClipFilename = str(self.tool_clip_file_path)

    def on_create(self, command, inputs):
        # Connect to the command object
        self.command = command

        # Add a tooclip image to the command
        self.command_definition.toolClipFilename = str(self.tool_clip_file_path)
        # Makes it so the command is not automatically executed when another
        # command gets activated.
        self.command.isExecutedWhenPreEmpted = False
        self.profile_data: dict

        # Checking and fixing profile_data json
        # Also adding parent path if it somehow is missing
        profile_path = Path(self.profiles_path)

        # Checking and fixing profile_data json
        # If parent folder somehow is missing, add it
        profile_path = Path(self.profiles_path)
        if not self.profiles_path.parent.exists():
            self.profiles_path.parent.mkdir(parents=True)

        if not profile_path.is_file():
            # Profile does not exist, recreate it from default
            configure.reset_single_profile_data("Cantilever")

        # Load profile data
        with open(profile_path, "r") as f:
            self.profile_data = json.load(f)
        self.createGUI()
        self.add_handlers()

    def on_destroy(self, command: adsk.core.Command, inputs: adsk.core.CommandInputs,
                   reason: adsk.core.CommandTerminationReason, input_values: dict):
        pass

    def on_preview(self, command: adsk.core.Command,
                   inputs: adsk.core.CommandInputs,
                   args: adsk.core.CommandEventArgs, input_values: dict):
        pass

    def createGUI(self):
        # Dividing command window into tabs
        inputs = self.command.commandInputs
        feature_tab = inputs.addTabCommandInput('tab_1', 'Feature').children

        gap_tab = inputs.addTabCommandInput('tab_3', 'Gaps').children

        # Geometry section
        geometry_group = feature_tab.addGroupCommandInput("geometry",
                                                          "Geometry")
        geo_list = geometry_group.children

        size_value = value_input(DEFAULT_SIZE)
        geo_list.addValueInput("size", "SIZE", "mm", size_value)


        # Gap section
        gap_group = feature_tab.addGroupCommandInput("gaps", "Gaps")
        default_gap_profile_name = self.profile_data['default_gap_profile']
        gap_profile = self.profile_data["gap_profiles"][
            default_gap_profile_name]

        gap_list = gap_group.children
        gap_profiles = gap_list.addDropDownCommandInput("gap_profiles",
                        "Profile", DropDownStyles.LabeledIconDropDownStyle)

        blank_icon_path = self.resources_path / "white"
        gap_profiles.maxVisibleItems = 10
        items = gap_profiles.listItems
        for key in self.profile_data['gap_profiles']:
            if key == default_gap_profile_name:
                items.add(key, True, str(blank_icon_path))
            else:
                items.add(key, False, str(blank_icon_path))

        for gap_par in self.GAP_PARAMETERS:
            geo_id = gap_par["id"]
            display_text = gap_par["display_text"]
            unit = gap_par["units"]
            value = value_input(gap_profile[geo_id])
            gap_list.addValueInput(geo_id, display_text, unit, value)

        # Selection section
        selections_group = feature_tab.addGroupCommandInput("selections",
                                                            "Selections")
        selections = selections_group.children
        joint_org_input = selections.addSelectionInput('selected_origin',
                                                       'Joint origin',
                                                       'Joint origin')
        jointOrigins = SelectionCommandInput.JointOrigins
        joint_org_input.addSelectionFilter(jointOrigins)
        joint_org_input.setSelectionLimits(0, 1)
        joint_org_input.tooltip = "First create a joint origin feature at " \
                                  "a certain position and orientation. Then" \
                                  " select it here to position the pin."

        try:
            join_body_input = selections.addSelectionInput("join_body",
                                                          'Body to join',
                                                          'Body to join')
            join_body_input.setSelectionLimits(0,1)
            join_body_input.addSelectionFilter(SelectionCommandInput.Bodies)
            join_body_input.tooltip = "Select the single body you want the " \
                                     "cantilever body to join."

        except:
            ui.messageBox(traceback.format_exc())
        cut_body_input = selections.addSelectionInput("cut_bodies",
                                                      'Bodies to cut',
                                                      'Bodies to cut')
        cut_body_input.addSelectionFilter(SelectionCommandInput.Bodies)
        cut_body_input.setSelectionLimits(0)
        cut_body_input.tooltip = "Select the bodies that you want the pin to" \
                                 " connect. A mating hole will be created for" \
                                 " the pin."

        """
            Position section
            Each button is an image. Fusion accepts a folder path and assumes
            the image has the name '16x16-normal.png' within that folder.
            It also uses the '16-16-disabled.png' for the other button state.
            Note that it is in fact possible to use an image that has different 
            dimensions than 16x16. Probably a bug.
            """
        # For choosing x_location
        joint_choice = selections.addButtonRowCommandInput("x_location",
                                                            "x location",
                                                            False)
        joint_choice.tooltip = "Choose the x-location of the origin."
        x_items = joint_choice.listItems

        x_top_folder_path = self.resources_path / "joint_pos_thickness" / "top"
        x_middle_folder_path = self.resources_path / "joint_pos_thickness" / "middle"
        x_bottom_folder_path = self.resources_path / "joint_pos_thickness" / "bottom"

        x_items.add("top", False, str(x_top_folder_path))
        x_items.add("middle", True, str(x_middle_folder_path))
        x_items.add("bottom", False, str(x_bottom_folder_path))

        # x_tooltip_path = self.RESOURCE_FOLDER / "joint_pos_height" / "tooltipclip.png"
        # joint_choice.toolClipFilename = str(x_tooltip_path)

        # y_location
        joint_choice = selections.addButtonRowCommandInput("y_location",
                                                            "y location",
                                                            False)
        y_items = joint_choice.listItems
        y_top_folder_path = self.resources_path / "joint_pos_length" / "top"
        y_middle_folder_path = self.resources_path / "joint_pos_length" / "middle"
        y_bottom_folder_path = self.resources_path / "joint_pos_length" / "bottom"

        y_items.add("top", True, str(y_top_folder_path))
        y_items.add("middle", False, str(y_middle_folder_path))
        y_items.add("bottom", False, str(y_bottom_folder_path))

        # y_tooltip_path = self.RESOURCE_FOLDER / "joint_pos_length" / "tooltipclip.png"
        # joint_choice.toolClipFilename = str(y_tooltip_path)
        joint_choice.tooltip = "Choose the y location of the origin."

        """
            Gap profile tab
            The gui elements make changes on the profile_data dictionary, but
            does not perform IO.
            """
        prof_settings = GapProfileSettings(self.profile_data)
        prof_settings.add_to_inputs(gap_tab)

    def add_handlers(self):
        cmd = self.command

        # Connect to the command related events.
        onExecutePreview = MyCommandExecutePreviewHandler()
        cmd.executePreview.add(onExecutePreview)
        handlers.append(onExecutePreview)

        onExecute = MyCommandExecuteHandler()
        cmd.execute.add(onExecute)
        handlers.append(onExecute)

        profile_switcher = ProfileSwitcher(self.profile_data)
        cmd.inputChanged.add(profile_switcher)
        handlers.append(profile_switcher)

        profile_modifier = ProfileModifier(self.profile_data, self.resources_path)
        cmd.inputChanged.add(profile_modifier)
        handlers.append(profile_modifier)

        j_updater = JsonUpdater(self.profile_data, self.profiles_path)
        cmd.inputChanged.add(j_updater)
        handlers.append(j_updater)

        input_limiter = InputLimiter()
        cmd.validateInputs.add(input_limiter)
        handlers.append(input_limiter)
