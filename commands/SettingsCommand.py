import adsk.core
import adsk.fusion
import adsk.cam
from adsk.core import SelectionCommandInput, DropDownStyles

import traceback
import json
import logging
import logging.handlers
from pathlib import Path
from ..lib.snaplib.control import value_input
from ..apper import apper
from ..lib.snaplib import configure


app = adsk.core.Application.get()
ui = app.userInterface
handlers = []



class MyCommandExecutePreviewHandler(adsk.core.CommandEventHandler):
    """
    Triggered when user makes any change to a parameter that is related to
    performing the feature operations.
    """
    def __init__(self):
        super().__init__()
        # self.logger = logging.getLogger(type(self).__name__)

    def notify(self, args):
        # ui.messageBox("Input triggered")
        pass


class InputHandler(adsk.core.InputChangedEventHandler):
    """
    Reacts when the 'size' field is changed, and changes a set of parameters
    by the "size_parameters" function. See its docstring for details.
    """
    def __init__(self):
        super().__init__()

    def notify(self, args):
        input_command = args.input
        cmd = args.inputs.command
        all_inputs = args.inputs.command.commandInputs
        settings = configure.get_settings()

        # Check if in key
        isinkeys = input_command.id in settings.keys()
        # ui.messageBox(f"hello {input_command.id=} \n {isinkeys=}\n{settings}")


        if input_command.id == "open_config_folder":
            try:
                import os, sys, platform, subprocess
                if platform.system() == "Windows":
                    os.startfile(str(configure.CONFIG_PATH))
                elif sys.platform == "darwin":
                    subprocess.call(["open", str(configure.CONFIG_PATH)])
                else:
                    print("Unsupported operating system.")
            except:
                ui.messageBox(f"Error: {traceback.format_exc()}")
        elif input_command.id == "reset_all_profile_data":
            try:
                configure.reset_all_profile_data()
            except:
                ui.messageBox(f"Error: {traceback.format_exc()}")
        elif input_command.id in settings["apps_enable"].keys():
            try:
                bool_value = input_command.value
                settings["apps_enable"][input_command.id] = bool_value
                # ui.messageBox(f"New settings:\n{settings}")
                configure.dump_settings(settings)
            except:
                ui.messageBox(traceback.format_exc())
        else:
            ui.messageBox("settings:" f"{str(settings)}")


class InputLimiter(adsk.core.ValidateInputsEventHandler):
    """
    Triggered when the user makes a change to any fields, and in fact it also
    triggers a bunch of additional times. Don't know why.
    If all the parameters are within acceptable intervals, it does nothing, and
    allows ExecutePreviewHandler or ExecuteHandler to be triggered. If any
    value is out of bounds, nothing happens, and any features that were
    previously generated by ExecutePreviewHandler will disappear.
    """

    def notify(self, args):
        try:
            pass

        except:
            ui.messageBox(traceback.format_exc())


class MyCommandExecuteHandler(adsk.core.CommandEventHandler):
    """
    Triggered when user clicks OK in command interface.
    """
    def __init__(self):
        super().__init__()
        #self.logger = logging.getLogger(type(self).__name__)

    def notify(self, args):
        #self.logger.info("Ok-button clicked.")
        #self.logger.debug("Triggered.")
        try:
            design = adsk.fusion.Design.cast(app.activeProduct)
            if design:
                pass
                #build(args, preview=False)
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))


class SettingsCommand(apper.Fusion360CommandBase):

    def __init__(self, name: str, options: dict):
        super().__init__(name, options)


    def on_execute(self, command: adsk.core.Command,
                   inputs: adsk.core.CommandInputs,
                   args: adsk.core.CommandEventArgs, input_values: dict):

        try:
            myCmdDef = ui.commandDefinitions.itemById(
                'SelectionEventsSample_Python')
            if myCmdDef is None:
                myCmdDef = ui.commandDefinitions.addButtonDefinition(
                    'SelectionEventsSample_Python',
                    'Settings', '', '')

            # # Connect to the command created event.
            # onCommandCreated = MyCommandCreatedHandler()
            # myCmdDef.commandCreated.add(onCommandCreated)
            # handlers.append(onCommandCreated)

            # prevent this module from being terminateD when the script returns,
            # because we are waiting for event handlers to fire
            adsk.autoTerminate(False)
            myCmdDef.execute()
        except:
            if ui:
                ui.messageBox('Failed:\n{}'.format(traceback.format_exc()))

    def on_run(self):
        super().on_run()
        # The image that pops up when hovering over the command icon
        #self.command_definition.toolClipFilename = str(self.tool_clip_file_path)

    def on_create(self, command, inputs):
        # Logging
        # Connect to the command object
        self.command = command

        # Add a tooclip image to the command
        # self.command_definition.toolClipFilename = str(self.tool_clip_file_path)
        # Makes it so the command is not automatically executed when another
        # command gets activated.
        self.command.isExecutedWhenPreEmpted = False
        # self.profile_data: dict
        self.add_handlers()
        self.createGUI()


    def on_destroy(self, command: adsk.core.Command, inputs: adsk.core.CommandInputs,
                   reason: adsk.core.CommandTerminationReason, input_values: dict):
        pass
        # self.logger.debug("onDestroy triggered.")
        # self.logger.info("# Command Window closed.")
        # Removing and closing all handlers
        # root_logger = logging.getLogger()
        # for handler in root_logger.handlers:
        #     handler.close()
        #     root_logger.removeHandler(handler)

    def on_preview(self, command: adsk.core.Command,
                   inputs: adsk.core.CommandInputs,
                   args: adsk.core.CommandEventArgs, input_values: dict):
        # logging.debug("Preview triggered.")
        pass


    def createGUI(self):
        # Load settings
        # with open(self.settings_json_path, "r") as f:
        #     settings = json.load(f)
        #

        # Dividing command window into tabs
        inputs = self.command.commandInputs
        feature_tab = inputs.addTabCommandInput('tab_1', 'Feature').children


        # Intended for resetting settings, but seems pointless
        # feature_tab.addBoolValueInput("reset_config", "Reset config", False, "", False)

        feature_tab.addBoolValueInput("open_config_folder", "Open config folder", False, "", False)
        feature_tab.addBoolValueInput("reset_all_profile_data", "Reset All Profile Data", False, "", False)


        """ Active apps refer to the functions that are currently enabled in the dropdown menu."""
        active_apps_group = feature_tab.addGroupCommandInput("active_apps",
                                                             "Enable/Disable functions")
        active_apps = active_apps_group.children
        settings = configure.get_settings()

        # Info text for enabling/disalbing functions
        active_apps.addTextBoxCommandInput("text_above_app_choices",
                                           "",
                                           "Add-in must be stopped and restarted to take effect.",
                                           1,
                                           True)

        """ This is purposely written explicitly instead of looping for clarity."""
        # Simple Pin
        key = "pin_simple_enabled"
        value = settings["apps_enable"][key]
        checkbox = active_apps.addBoolValueInput(key, "Simple Pin",  True)
        checkbox.value = value

        # Advanced Pin
        key = "pin_advanced_enabled"
        value = settings["apps_enable"][key]
        checkbox = active_apps.addBoolValueInput(key, "Pin",  True)
        checkbox.value = value

        # Simple Cantilever
        key = "cantilever_simple_enabled"
        value = settings["apps_enable"][key]
        checkbox = active_apps.addBoolValueInput(key, "Simple Cantilever",  True)
        checkbox.value = value

        # Advanced Cantilever
        key = "cantilever_advanced_enabled"
        value = settings["apps_enable"][key]
        checkbox = active_apps.addBoolValueInput(key, "Cantilever",  True)
        checkbox.value = value

    def add_handlers(self):
        app = adsk.core.Application.get()
        ui = app.userInterface
        cmd = self.command

        # Connect to the command related events.
        onExecutePreview = MyCommandExecutePreviewHandler()
        cmd.executePreview.add(onExecutePreview)
        handlers.append(onExecutePreview)

        onExecute = MyCommandExecuteHandler()
        cmd.execute.add(onExecute)
        handlers.append(onExecute)

        input_handler = InputHandler()
        cmd.inputChanged.add(input_handler)
        handlers.append(input_handler)

        input_limiter = InputLimiter()
        cmd.validateInputs.add(input_limiter)
        handlers.append(input_limiter)